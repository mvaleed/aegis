// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package sqlcdb

import (
	"context"
	"time"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const assignPermissionToRole = `-- name: AssignPermissionToRole :exec
INSERT INTO role_permissions (role_id, permission_id)
VALUES ($1, $2)
ON CONFLICT (role_id, permission_id) DO NOTHING
`

type AssignPermissionToRoleParams struct {
	RoleID       uuid.UUID `json:"role_id"`
	PermissionID uuid.UUID `json:"permission_id"`
}

func (q *Queries) AssignPermissionToRole(ctx context.Context, arg AssignPermissionToRoleParams) error {
	_, err := q.db.Exec(ctx, assignPermissionToRole, arg.RoleID, arg.PermissionID)
	return err
}

const assignRoleToUser = `-- name: AssignRoleToUser :exec
INSERT INTO user_roles (user_id, role_id)
VALUES ($1, $2)
ON CONFLICT (user_id, role_id) DO NOTHING
`

type AssignRoleToUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoleID uuid.UUID `json:"role_id"`
}

func (q *Queries) AssignRoleToUser(ctx context.Context, arg AssignRoleToUserParams) error {
	_, err := q.db.Exec(ctx, assignRoleToUser, arg.UserID, arg.RoleID)
	return err
}

const countRolesWithPermission = `-- name: CountRolesWithPermission :one
SELECT COUNT(*) FROM role_permissions WHERE permission_id = $1
`

func (q *Queries) CountRolesWithPermission(ctx context.Context, permissionID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countRolesWithPermission, permissionID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsers = `-- name: CountUsers :one
SELECT COUNT(*) FROM users
WHERE deleted_at IS NULL
    AND ($1::user_status IS NULL OR status = $1)
    AND ($2::user_type IS NULL OR user_type = $2)
    AND ($3::text = '' OR 
         LOWER(email) LIKE LOWER('%' || $3 || '%') OR
         LOWER(username) LIKE LOWER('%' || $3 || '%') OR
         LOWER(full_name) LIKE LOWER('%' || $3 || '%'))
`

type CountUsersParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
}

func (q *Queries) CountUsers(ctx context.Context, arg CountUsersParams) (int64, error) {
	row := q.db.QueryRow(ctx, countUsers, arg.Column1, arg.Column2, arg.Column3)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countUsersWithRole = `-- name: CountUsersWithRole :one
SELECT COUNT(*) FROM user_roles WHERE role_id = $1
`

func (q *Queries) CountUsersWithRole(ctx context.Context, roleID uuid.UUID) (int64, error) {
	row := q.db.QueryRow(ctx, countUsersWithRole, roleID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createPermission = `-- name: CreatePermission :one
INSERT INTO permissions (id, resource, action, description, created_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, resource, action, description, created_at
`

type CreatePermissionParams struct {
	ID          uuid.UUID `json:"id"`
	Resource    string    `json:"resource"`
	Action      string    `json:"action"`
	Description *string   `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
}

func (q *Queries) CreatePermission(ctx context.Context, arg CreatePermissionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, createPermission,
		arg.ID,
		arg.Resource,
		arg.Action,
		arg.Description,
		arg.CreatedAt,
	)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO refresh_tokens (
    id, user_id, token_hash, expires_at, created_at,
    ip_address, user_agent
) VALUES ($1, $2, $3, $4, $5, $6, $7)
RETURNING id, user_id, token_hash, expires_at, created_at, revoked_at, ip_address, user_agent, replaced_by_id
`

type CreateRefreshTokenParams struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	TokenHash string    `json:"token_hash"`
	ExpiresAt time.Time `json:"expires_at"`
	CreatedAt time.Time `json:"created_at"`
	IpAddress *string   `json:"ip_address"`
	UserAgent *string   `json:"user_agent"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.ID,
		arg.UserID,
		arg.TokenHash,
		arg.ExpiresAt,
		arg.CreatedAt,
		arg.IpAddress,
		arg.UserAgent,
	)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.ReplacedByID,
	)
	return i, err
}

const createRole = `-- name: CreateRole :one
INSERT INTO roles (id, name, description, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5)
RETURNING id, name, description, created_at, updated_at
`

type CreateRoleParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) CreateRole(ctx context.Context, arg CreateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, createRole,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id, email, password_hash, phone, username, full_name,
    user_type, status, email_verified, phone_verified,
    created_at, updated_at, version
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13
)
RETURNING id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version
`

type CreateUserParams struct {
	ID            uuid.UUID `json:"id"`
	Email         string    `json:"email"`
	PasswordHash  string    `json:"password_hash"`
	Phone         *string   `json:"phone"`
	Username      string    `json:"username"`
	FullName      string    `json:"full_name"`
	UserType      string    `json:"user_type"`
	Status        string    `json:"status"`
	EmailVerified bool      `json:"email_verified"`
	PhoneVerified bool      `json:"phone_verified"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	Version       int32     `json:"version"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Username,
		arg.FullName,
		arg.UserType,
		arg.Status,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.CreatedAt,
		arg.UpdatedAt,
		arg.Version,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}

const deleteExpiredTokens = `-- name: DeleteExpiredTokens :execrows
DELETE FROM refresh_tokens
WHERE expires_at < NOW() - INTERVAL '7 days'
`

func (q *Queries) DeleteExpiredTokens(ctx context.Context) (int64, error) {
	result, err := q.db.Exec(ctx, deleteExpiredTokens)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected(), nil
}

const deletePermission = `-- name: DeletePermission :exec
DELETE FROM permissions WHERE id = $1
`

func (q *Queries) DeletePermission(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePermission, id)
	return err
}

const deleteRole = `-- name: DeleteRole :exec
DELETE FROM roles WHERE id = $1
`

func (q *Queries) DeleteRole(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteRole, id)
	return err
}

const getPermissionByID = `-- name: GetPermissionByID :one
SELECT id, resource, action, description, created_at FROM permissions WHERE id = $1
`

func (q *Queries) GetPermissionByID(ctx context.Context, id uuid.UUID) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByID, id)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getPermissionByResourceAction = `-- name: GetPermissionByResourceAction :one
SELECT id, resource, action, description, created_at FROM permissions WHERE resource = $1 AND action = $2
`

type GetPermissionByResourceActionParams struct {
	Resource string `json:"resource"`
	Action   string `json:"action"`
}

func (q *Queries) GetPermissionByResourceAction(ctx context.Context, arg GetPermissionByResourceActionParams) (Permission, error) {
	row := q.db.QueryRow(ctx, getPermissionByResourceAction, arg.Resource, arg.Action)
	var i Permission
	err := row.Scan(
		&i.ID,
		&i.Resource,
		&i.Action,
		&i.Description,
		&i.CreatedAt,
	)
	return i, err
}

const getRefreshTokenByHash = `-- name: GetRefreshTokenByHash :one
SELECT id, user_id, token_hash, expires_at, created_at, revoked_at, ip_address, user_agent, replaced_by_id FROM refresh_tokens WHERE token_hash = $1
`

func (q *Queries) GetRefreshTokenByHash(ctx context.Context, tokenHash string) (RefreshToken, error) {
	row := q.db.QueryRow(ctx, getRefreshTokenByHash, tokenHash)
	var i RefreshToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TokenHash,
		&i.ExpiresAt,
		&i.CreatedAt,
		&i.RevokedAt,
		&i.IpAddress,
		&i.UserAgent,
		&i.ReplacedByID,
	)
	return i, err
}

const getRoleByID = `-- name: GetRoleByID :one
SELECT id, name, description, created_at, updated_at FROM roles WHERE id = $1
`

func (q *Queries) GetRoleByID(ctx context.Context, id uuid.UUID) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByID, id)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRoleByName = `-- name: GetRoleByName :one
SELECT id, name, description, created_at, updated_at FROM roles WHERE name = $1
`

func (q *Queries) GetRoleByName(ctx context.Context, name string) (Role, error) {
	row := q.db.QueryRow(ctx, getRoleByName, name)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getRolePermissions = `-- name: GetRolePermissions :many
SELECT p.id, p.resource, p.action, p.description, p.created_at FROM permissions p
JOIN role_permissions rp ON p.id = rp.permission_id
WHERE rp.role_id = $1
ORDER BY p.resource, p.action
`

func (q *Queries) GetRolePermissions(ctx context.Context, roleID uuid.UUID) ([]Permission, error) {
	rows, err := q.db.Query(ctx, getRolePermissions, roleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version FROM users
WHERE LOWER(email) = LOWER($1) AND deleted_at IS NULL
`

func (q *Queries) GetUserByEmail(ctx context.Context, lower string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmail, lower)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version FROM users
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByID(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}

const getUserByIDIncludeDeleted = `-- name: GetUserByIDIncludeDeleted :one
SELECT id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version FROM users
WHERE id = $1
`

func (q *Queries) GetUserByIDIncludeDeleted(ctx context.Context, id uuid.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getUserByIDIncludeDeleted, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}

const getUserByUsername = `-- name: GetUserByUsername :one
SELECT id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version FROM users
WHERE username = $1 AND deleted_at IS NULL
`

func (q *Queries) GetUserByUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}

const getUserRoles = `-- name: GetUserRoles :many
SELECT r.id, r.name, r.description, r.created_at, r.updated_at FROM roles r
JOIN user_roles ur ON r.id = ur.role_id
WHERE ur.user_id = $1
ORDER BY r.name
`

func (q *Queries) GetUserRoles(ctx context.Context, userID uuid.UUID) ([]Role, error) {
	rows, err := q.db.Query(ctx, getUserRoles, userID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPermissions = `-- name: ListPermissions :many
SELECT id, resource, action, description, created_at FROM permissions ORDER BY resource, action
`

func (q *Queries) ListPermissions(ctx context.Context) ([]Permission, error) {
	rows, err := q.db.Query(ctx, listPermissions)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Permission{}
	for rows.Next() {
		var i Permission
		if err := rows.Scan(
			&i.ID,
			&i.Resource,
			&i.Action,
			&i.Description,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listRoles = `-- name: ListRoles :many
SELECT id, name, description, created_at, updated_at FROM roles ORDER BY name
`

func (q *Queries) ListRoles(ctx context.Context) ([]Role, error) {
	rows, err := q.db.Query(ctx, listRoles)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Role{}
	for rows.Next() {
		var i Role
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listUsers = `-- name: ListUsers :many
SELECT id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version FROM users
WHERE deleted_at IS NULL
    AND ($1::user_status IS NULL OR status = $1)
    AND ($2::user_type IS NULL OR user_type = $2)
    AND ($3::text = '' OR 
         LOWER(email) LIKE LOWER('%' || $3 || '%') OR
         LOWER(username) LIKE LOWER('%' || $3 || '%') OR
         LOWER(full_name) LIKE LOWER('%' || $3 || '%'))
ORDER BY created_at DESC
LIMIT $4 OFFSET $5
`

type ListUsersParams struct {
	Column1 string `json:"column_1"`
	Column2 string `json:"column_2"`
	Column3 string `json:"column_3"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

func (q *Queries) ListUsers(ctx context.Context, arg ListUsersParams) ([]User, error) {
	rows, err := q.db.Query(ctx, listUsers,
		arg.Column1,
		arg.Column2,
		arg.Column3,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Phone,
			&i.Username,
			&i.FullName,
			&i.UserType,
			&i.Status,
			&i.EmailVerified,
			&i.PhoneVerified,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.Version,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markTokenReplaced = `-- name: MarkTokenReplaced :exec
UPDATE refresh_tokens SET
    revoked_at = NOW(),
    replaced_by_id = $2
WHERE id = $1
`

type MarkTokenReplacedParams struct {
	ID           uuid.UUID   `json:"id"`
	ReplacedByID pgtype.UUID `json:"replaced_by_id"`
}

func (q *Queries) MarkTokenReplaced(ctx context.Context, arg MarkTokenReplacedParams) error {
	_, err := q.db.Exec(ctx, markTokenReplaced, arg.ID, arg.ReplacedByID)
	return err
}

const removePermissionFromRole = `-- name: RemovePermissionFromRole :exec
DELETE FROM role_permissions
WHERE role_id = $1 AND permission_id = $2
`

type RemovePermissionFromRoleParams struct {
	RoleID       uuid.UUID `json:"role_id"`
	PermissionID uuid.UUID `json:"permission_id"`
}

func (q *Queries) RemovePermissionFromRole(ctx context.Context, arg RemovePermissionFromRoleParams) error {
	_, err := q.db.Exec(ctx, removePermissionFromRole, arg.RoleID, arg.PermissionID)
	return err
}

const removeRoleFromUser = `-- name: RemoveRoleFromUser :exec
DELETE FROM user_roles
WHERE user_id = $1 AND role_id = $2
`

type RemoveRoleFromUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	RoleID uuid.UUID `json:"role_id"`
}

func (q *Queries) RemoveRoleFromUser(ctx context.Context, arg RemoveRoleFromUserParams) error {
	_, err := q.db.Exec(ctx, removeRoleFromUser, arg.UserID, arg.RoleID)
	return err
}

const revokeAllUserRefreshTokens = `-- name: RevokeAllUserRefreshTokens :exec
UPDATE refresh_tokens SET revoked_at = NOW()
WHERE user_id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeAllUserRefreshTokens(ctx context.Context, userID uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeAllUserRefreshTokens, userID)
	return err
}

const revokeRefreshToken = `-- name: RevokeRefreshToken :exec
UPDATE refresh_tokens SET revoked_at = NOW()
WHERE id = $1 AND revoked_at IS NULL
`

func (q *Queries) RevokeRefreshToken(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, revokeRefreshToken, id)
	return err
}

const softDeleteUser = `-- name: SoftDeleteUser :exec
UPDATE users SET
    deleted_at = NOW(),
    updated_at = NOW()
WHERE id = $1 AND deleted_at IS NULL
`

func (q *Queries) SoftDeleteUser(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.Exec(ctx, softDeleteUser, id)
	return err
}

const updateRole = `-- name: UpdateRole :one
UPDATE roles SET
    name = $2,
    description = $3,
    updated_at = $4
WHERE id = $1
RETURNING id, name, description, created_at, updated_at
`

type UpdateRoleParams struct {
	ID          uuid.UUID `json:"id"`
	Name        string    `json:"name"`
	Description *string   `json:"description"`
	UpdatedAt   time.Time `json:"updated_at"`
}

func (q *Queries) UpdateRole(ctx context.Context, arg UpdateRoleParams) (Role, error) {
	row := q.db.QueryRow(ctx, updateRole,
		arg.ID,
		arg.Name,
		arg.Description,
		arg.UpdatedAt,
	)
	var i Role
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users SET
    email = $2,
    password_hash = $3,
    phone = $4,
    username = $5,
    full_name = $6,
    user_type = $7,
    status = $8,
    email_verified = $9,
    phone_verified = $10,
    updated_at = $11,
    version = version + 1
WHERE id = $1 AND version = $12 AND deleted_at IS NULL
RETURNING id, email, password_hash, phone, username, full_name, user_type, status, email_verified, phone_verified, created_at, updated_at, deleted_at, version
`

type UpdateUserParams struct {
	ID            uuid.UUID `json:"id"`
	Email         string    `json:"email"`
	PasswordHash  string    `json:"password_hash"`
	Phone         *string   `json:"phone"`
	Username      string    `json:"username"`
	FullName      string    `json:"full_name"`
	UserType      string    `json:"user_type"`
	Status        string    `json:"status"`
	EmailVerified bool      `json:"email_verified"`
	PhoneVerified bool      `json:"phone_verified"`
	UpdatedAt     time.Time `json:"updated_at"`
	Version       int32     `json:"version"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.Phone,
		arg.Username,
		arg.FullName,
		arg.UserType,
		arg.Status,
		arg.EmailVerified,
		arg.PhoneVerified,
		arg.UpdatedAt,
		arg.Version,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Phone,
		&i.Username,
		&i.FullName,
		&i.UserType,
		&i.Status,
		&i.EmailVerified,
		&i.PhoneVerified,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
		&i.Version,
	)
	return i, err
}
